// Generated by CoffeeScript 1.7.1
(function() {
  var Q, S3Deployer, fs, glob, mime, path, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  fs = require('fs');

  mime = require('mime');

  _ = require('lodash');

  Q = require('q');

  glob = require('glob');

  path = require('path');

  S3Deployer = (function() {
    function S3Deployer(packageJson, client, options) {
      this.packageJson = packageJson;
      this.client = client;
      this.options = options != null ? options : {};
      this.batchUploadFileArray = __bind(this.batchUploadFileArray, this);
      this.upload = __bind(this.upload, this);
      this.prepareFileArray = __bind(this.prepareFileArray, this);
      this.deploy = __bind(this.deploy, this);
      this.packageName = this.packageJson.name;
      this.deployDirectory = this.packageJson.deploy;
    }

    S3Deployer.prototype.deploy = function() {
      var fileArray;
      if (this.options.dryrun) {
        console.log("Running in dry run");
      }
      fileArray = this.prepareFileArray();
      return this.batchUploadFileArray(fileArray, this.options.chunk, this.options.batchTimeout);
    };

    S3Deployer.prototype.prepareFileArray = function() {
      var files;
      files = glob.sync("**", {
        mark: true,
        cwd: this.deployDirectory
      });
      files = _.reject(files, function(f) {
        return f.charAt(f.length - 1) === '/';
      });
      return _.map(files, (function(_this) {
        return function(f) {
          return {
            src: path.join(_this.deployDirectory, f),
            dest: _this.packageName + '/' + f
          };
        };
      })(this));
    };

    S3Deployer.prototype.upload = function(src, dest) {
      var data, deferred, req, timeoutCallback, timeoutMillis;
      if (!src) {
        throw new Error("Paremeter src is required");
      }
      if (!dest) {
        throw new Error("Paremeter dest is required");
      }
      if (this.options.verbose) {
        console.log("Uploading file " + src + " to " + dest);
      }
      if (this.options.dryrun) {
        return Q();
      }
      deferred = Q.defer();
      data = fs.readFileSync(src);
      req = this.client.put(dest, {
        "Content-Length": data.length,
        "Content-Type": mime.lookup(dest)
      });
      timeoutMillis = this.options.fileTimeout || 1000 * 30;
      timeoutCallback = function() {
        req.abort();
        return deferred.reject(new Error("Timeout exceeded when uploading " + dest));
      };
      req.setTimeout(timeoutMillis, timeoutCallback);
      req.on("error", function(err) {
        return deferred.reject(new Error(err));
      });
      req.on("response", function(res) {
        data = "";
        res.on('data', function(chunk) {
          return data += chunk;
        });
        return res.on('end', function(chunk) {
          if (chunk) {
            data += chunk;
          }
          if (200 === res.statusCode) {
            return deferred.resolve(data);
          } else {
            return deferred.reject(new Error("Failed to upload " + dest + ", status: " + res.statusCode + ", \n " + data));
          }
        });
      });
      req.end(data);
      return deferred.promise;
    };

    S3Deployer.prototype.batchUploadFileArray = function(fileArray, chunk, timeout) {
      var batches, deferred, index, timeoutKey, upload, _i, _ref;
      if (chunk == null) {
        chunk = 20;
      }
      if (timeout == null) {
        timeout = 1000 * 60 * 5;
      }
      if (this.options.verbose) {
        console.log('Starting deploy, chunk:', chunk, 'timeout:', timeout);
      }
      deferred = Q.defer();
      upload = Q();
      batches = [];
      for (index = _i = 0, _ref = fileArray.length; chunk > 0 ? _i <= _ref : _i >= _ref; index = _i += chunk) {
        batches.push(fileArray.slice(index, index + chunk));
      }
      batches.forEach((function(_this) {
        return function(fileArrayBatch, batchIndex) {
          if (_this.options.verbose) {
            console.log('Batch', batchIndex);
          }
          return upload = upload.then(function() {
            return Q.all(_.map(fileArrayBatch, function(file, i) {
              return _this.upload(file.src, file.dest).then(function() {
                return deferred.notify("[" + String('000' + ((batchIndex * chunk) + i + 1)).slice(-3) + "/" + String('000' + ((batchIndex * chunk) + fileArrayBatch.length)).slice(-3) + "]" + (" https://" + _this.client.bucket + ".s3.amazonaws.com/" + file.dest));
              });
            }));
          });
        };
      })(this));
      timeoutKey = setTimeout((function() {
        throw new Error("Timeout exceeded when uploading files");
      }), timeout);
      upload.then(function() {
        clearTimeout(timeoutKey);
        return deferred.resolve();
      });
      upload.fail(function(reason) {
        return deferred.reject(reason);
      });
      return deferred.promise;
    };

    return S3Deployer;

  })();

  module.exports = S3Deployer;

}).call(this);
